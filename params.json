{"name":"Guice","tagline":"Mycila Guice Extensions","body":"#summary Mycila Guice\r\n\r\n<wiki:toc max_depth=\"5\" />\r\n\r\n= Introduction =\r\n\r\nMycilaGuice is an extension library to [http://code.google.com/p/google-guice/ Google Guice 3] which adds many features such as:\r\n\r\n contributions:\r\n * JSR250 (`@Resource`, `@PreDestroy`, `@PostConstruct`)\r\n * Additional scopes\r\n * Testing integration\r\n * Service loader facilities\r\n * Binding helpers\r\n * Support of legacy classes (classes you cannot modify to add @Inject)\r\n\r\nThe project can be used with Guice 2 or 3 and supports JSR330 (javax.inject)\r\n\r\n= Download =\r\n\r\nMycila Guice is deployed in maven 2 Central Repository:\r\n\r\nhttp://repo2.maven.org/maven2/com/mycila/mycila-guice/\r\n\r\n{{{\r\n<dependency>\r\n    <groupId>com.mycila</groupId>\r\n    <artifactId>mycila-guice</artifactId>\r\n    <version>X.Y</version>\r\n</dependency>\r\n}}}\r\n\r\n * [http://code.google.com/p/mycila/source/browse/#svn/mycila-guice/trunk Browse source code]\r\n * [http://mycila.googlecode.com/svn/mycila-guice/trunk/ Checkout URL]\r\n\r\nSnapshots and releases are also availables at\r\n * https://mc-repo.googlecode.com/svn/maven2/snapshots/com/mycila/mycila-guice/\r\n * https://mc-repo.googlecode.com/svn/maven2/releases/com/mycila/mycila-guice/\r\n\r\n= Mycila Guice Features =\r\n\r\n== JSR250 ==\r\n\r\n=== Creating your injector ===\r\n\r\nUsing the plain old Guice way, by using the `Jsr250Module`.\r\n\r\n{{{\r\nInjector injector = Guice.createInjector(Stage.PRODUCTION, new MyModule(), new Jsr250Module());\r\n}}}\r\n\r\nOr by using the `Jsr250` helper class, which will return you a `Jsr250Injector`, which is a subclass of Guice's Injector.\r\n\r\n{{{\r\nJsr250Injector jsr250Injector = Jsr250.createInjector(Stage.PRODUCTION, new MyModule());\r\n}}}\r\n\r\nWe hardly recommend to use the later form because you can manage the lifecycle of the JSR250 injector and objects more easily with the destroy() method:\r\n\r\n{{{\r\npublic interface Jsr250Injector extends Injector {\r\n    void destroy();\r\n}\r\n}}}\r\n\r\n=== Injecting using `@Resource` ===\r\n\r\nYou can inject fields and methods as usual, and also benefits of Guice's binding annotations and providers.\r\n\r\nFields are always injected before methods.\r\n\r\n{{{\r\npublic class Account {\r\n\r\n    @Resource\r\n    Bank bank;\r\n\r\n    String number;\r\n\r\n    @Resource\r\n    void init(Client client, @Named(\"RNG\") Provider<Id> rng) {\r\n        number = bank.id() + \"\" + client.id() + \"\" + rng.get().id();\r\n    }\r\n\r\n    public String getNumber() {\r\n        return number;\r\n    }\r\n}\r\n}}}\r\n\r\n=== Controlling lifecycle with `@PostConstruct` and `@PreDestroy` ===\r\n\r\nYou can annotate no argument methods with these annotation.\r\n * Methods annotated by `@PostConstruct` will be executed after injection is completed.\r\n * Methods annotated by `@PreDestroy` will be executed when closing the injector\r\n\r\n{{{\r\n@Singleton\r\npublic class Bank {\r\n\r\n    List<Account> accounts = new ArrayList<Account>();\r\n\r\n    @Resource\r\n    Provider<Account> provider;\r\n\r\n    @PostConstruct\r\n    void openBank() {\r\n        // create two account initially\r\n        accounts.add(provider.get());\r\n        accounts.add(provider.get());\r\n    }\r\n\r\n    @PreDestroy\r\n    void closeBank() {\r\n        accounts.clear();\r\n    }\r\n\r\n    int id() { return 2; }\r\n    List<Account> accounts() { return accounts; }\r\n}\r\n}}}\r\n\r\nPost construction methods are handled automatically. But `@PreDestroy` methods can only be called on singleton instances or scoped instances, when closing the `Jsr250Injector`.\r\n\r\nIf you don't use the `Jsr250Injector`, you need to retreive the `Jsr250Destroyer` to destroy singletons before closing the application.\r\n\r\nHere is the two ways. When using the `Jsr250Injector`:\r\n\r\n{{{\r\njsr250Injector.destroy();\r\n}}}\r\n\r\nOr when using Guice's default injector:\r\n\r\n{{{\r\ninjector.getInstance(Jsr250Destroyer.class).preDestroy();\r\n}}}\r\n\r\n== Binding helpers ==\r\n\r\n=== Overview ===\r\n\r\n`BinderHelper` is a class which help you deal more easily with Mycila Guice features. To use is, you can do a static import of this class:\r\n\r\n{{{\r\nimport static com.mycila.inject.BinderHelper.in;\r\n}}}\r\n\r\nThen in your module you can use:\r\n\r\n{{{\r\n// Bind an instance to a class and also request injection on that instance\r\nin(binder()).bind(MyClass, myInstance);\r\n\r\n// Bind several interceptors at once, and also request injection on them\r\nin(binder()).bindInterceptor(classMatcher, methodMatcher, interceptor1, interceptor2)\r\n\r\n// Add support for an external annotation to be used for post injection handlers\r\nin(binder()).bindAfterInjection(PostConstruct.class, Jsr250MethodHandler.class);\r\n\r\n// Add support for an external annotation to be used to inject members besides the usual @Inject\r\nin(binder()).bindAnnotationInjector(Resource.class, ResourceKeyProvider.class)\r\n\r\n// Manually bind some additional scopes\r\nbindScope(RenewableSingleton.class, in(binder()).renewableSingleton(1, TimeUnit.DAYS));\r\nbindScope(ExpiringSingleton.class, in(binder()).expiringSingleton(1, TimeUnit.DAYS));\r\nbindScope(ConcurrentSingleton.class, in(binder()).concurrentSingleton(20, TimeUnit.SECONDS));\r\nbindScope(ResetSingleton.class, in(binder()).resetSingleton());\r\nbindScope(WeakSingleton.class, in(binder()).weakSingleton());\r\nbindScope(SoftSingleton.class, in(binder()).softSingleton());\r\n}}}\r\n\r\nMost of the calls are chainable (fluent api). In example:\r\n\r\n{{{\r\nin(binder)\r\n    .bindAnnotationInjector(Resource.class, Jsr250KeyProvider.class)\r\n    .bindAfterInjection(PostConstruct.class, Jsr250PostConstructHandler.class)\r\n    .bind(Jsr250Destroyer.class, new Jsr250Destroyer());\r\n}}}\r\n\r\n=== Customizing injection annotation ===\r\n\r\nIn example, suppose you have your own annotation called `@Autowire` to inject dependencies. You could automatically support `@Resource`, `@Inject` and `@Autowire` at the same time. Supposing you'd like to use this annotation:\r\n\r\n{{{\r\n@Target({METHOD, CONSTRUCTOR, FIELD})\r\n@Retention(RUNTIME)\r\npublic @interface Autowire {\r\n    String value() default \"\";\r\n}\r\n}}}\r\n\r\nYou have to define a `KeyProvider` which help creating the Guice key used to recover a dependency from the annotation information plus the injected member.\r\n\r\n{{{\r\nstatic final class AutowireKeyProvider extends KeyProviderSkeleton<Autowire> {\r\n    @Override\r\n    public Key<?> getKey(TypeLiteral<?> injectedType, Field injectedMember, Autowire resourceAnnotation) {\r\n        String name = resourceAnnotation.value();\r\n        return name.length() == 0 ?\r\n                super.getKey(injectedType, injectedMember, resourceAnnotation) :\r\n                Key.get(injectedType.getFieldType(injectedMember), Names.named(name));\r\n    }\r\n}\r\n}}}\r\n\r\n{{{\r\nJsr250Injector jsr250Injector = Jsr250.createInjector(new MyModule(), new AbstractModule() {\r\n    @Override\r\n    protected void configure() {\r\n        in(binder()).bindAnnotationInjector(Autowire.class, AutowireKeyProvider.class);\r\n    }\r\n});\r\n}}}\r\n\r\n== Additional scopes ==\r\n\r\nYou can install additional scopes in one way by running one of these two lines:\r\n\r\n{{{\r\nJsr250Injector jsr250Injector = Jsr250.createInjector(new ExtraScopeModule(), new MyModule());\r\n\r\nInjector injector = Guice.createInjector(new ExtraScopeModule(), new MyModule());\r\n}}}\r\n\r\nThis module installs these additional scopes:\r\n * `@ConcurrentSingleton` (with a thread timeout of 20 seconds)\r\n * `@WeakSingleton`\r\n * `@SoftSingleton`\r\n * `@ResetSingleton`\r\n\r\nTwo other scopes are available to be bound manually:\r\n * `@ExpiringSingleton`\r\n * `@RenewableSingleton`\r\n\r\n== Legacy support ==\r\n\r\n== Service Loader ==\r\n\r\n{{{\r\nbinder.bind(AgentPlugin[].class)\r\n    .toProvider(ServiceLoaderProvider.of(AgentPlugin.class).withClassLoader(ClassLoader.class))\r\n    .in(Cached20Seconds.class);\r\n}}}\r\n\r\nThis binding creates in a cached scope for 20 seconds a list of AgentPlugin instances on the classpath, loaded by the JDK ServiceLoader (META-INF/services/...). When loaded, each service will be injected with its dependencies.\r\n\r\n*or*\r\n\r\n{{{\r\ninstall(ServiceLoaderModule.withClassLoader(ClassLoader.class).of(AgentPlugin.class));\r\n}}}\r\n\r\nIn this case. the module creates a binding of key `Set<AgentPlugin>` containing all loaded and injected instances from the META-INF/services definitions.\r\n\r\n`withClassLoader` is optional and takes as parameter the KEY of the binding where to get the classloader. In my case, i have a binding of type ClassLoader which points to the ClassLaoder instance i want to use to discover the services.\r\n\r\n== Testing integration ==\r\n\r\n\r\n[![Build Status](https://travis-ci.org/mycila/guice.png?branch=master)](https://travis-ci.org/mycila/guice)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}